/*
 * linux/reciva/reciva_mode_switch_button.c
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * Copyright (c) 2004, 2007 Reciva Ltd. All Rights Reserved
 *
 * Description:
 *   Mode switching controlled via GPIO input lines
 *   GPG6, GPG7
 *   00 x
 *   01 FM
 *   10 IR
 *
 */

   /*************************************************************************/
   /***                        Include Files                              ***/
   /*************************************************************************/

#include <linux/module.h>
#include <linux/proc_fs.h>
#include <linux/input.h>
#include <linux/init.h>
#include <linux/miscdevice.h>

#include <asm/delay.h>
#include <asm/hardware.h>
#include <asm/irq.h>
#include <asm/arch/regs-gpio.h>
#include <asm/io.h>
#include <asm/uaccess.h>

#include "reciva_keypad_generic.h"

   /*************************************************************************/
   /***                        Local Constants                            ***/
   /*************************************************************************/

#define MIN(a,b) ( (a)<(b) ? (a):(b) )

   /*************************************************************************/
   /***                        Static Data                                ***/
   /*************************************************************************/

static int mode_switch_read (struct file *filp, char *buffer, size_t count, loff_t *ppos);

static struct input_dev *input_dev;
static int mode;
static struct timer_list timer;

/* IOCTL related */
static struct file_operations mode_switch_fops =
{
  owner:    THIS_MODULE,
  read:     mode_switch_read,
};

static struct miscdevice mode_switch_miscdev =
{
  MISC_DYNAMIC_MINOR,
  "mode_switch",
  &mode_switch_fops
};

   /*************************************************************************/
   /***                        Private functions                          ***/
   /*************************************************************************/

static int
mode_from_gpio (void)
{
  int b0 = s3c2410_gpio_getpin (S3C2410_GPG14) ? 1 : 0;
  int b1 = s3c2410_gpio_getpin (S3C2410_GPG15) ? 1 : 0;

  return b0 | (b1 << 1);
}

static int 
mode_switch_read (struct file *filp, char *buffer, size_t count, loff_t *ppos)
{
  char buf[3];
  int c;
  sprintf (buf, "%1d", mode_from_gpio ());
  c = MIN (count, 2);
  if (copy_to_user (buffer, buf, c))
    return -EFAULT;
  return c;
}

static void
report_state (void)
{
  int code;

  switch (mode) {
  case 0:       // OFF
    code = RKD_POWER_OFF;
    break;

  case 2:       // IR
    code = RKD_SWITCH_MODE_TO_IRADIO;
    break;

  case 1:       // FM
    code = RKD_SWITCH_MODE_TO_FM;
    break;

  default:
    printk("unknown mode %d\n", mode);
    return;
  }

  input_report_key(input_dev, code, 1);
  input_report_key(input_dev, code, 0);

#ifdef KERNEL_26
  input_sync (input_dev);
#endif
}

static void 
timer_func (unsigned long time)
{
  int new_mode = mode_from_gpio ();

  if (new_mode != mode)
    {
      printk ("switching to mode %d\n", new_mode);

      mode = new_mode;
      report_state ();
    }
}

/****************************************************************************
 * Handles interrupt generated by the mode switch buttons
 ****************************************************************************/
static void 
int_handler(int irq, void *dev, struct pt_regs *regs)
{
  printk("band switch irq\n");
  mod_timer (&timer, jiffies + (HZ / 10));
}

/*****************************************************************************
 * Initialise kernel module
 *****************************************************************************/
static spinlock_t init_lock = SPIN_LOCK_UNLOCKED;

static int  
mode_switch_init (void) 
{
  unsigned long flags;

  /* Set up the input device */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
  input_dev = input_allocate_device();
#else
  input_dev = kmalloc(sizeof(*input_dev), GFP_KERNEL);
  memset(input_dev, 0, sizeof(*input_dev));
#endif

  input_dev->evbit[0] = BIT(EV_KEY);
  set_bit(RKD_SWITCH_MODE_TO_IRADIO, input_dev->keybit);
  set_bit(RKD_SWITCH_MODE_TO_FM, input_dev->keybit);
  set_bit(RKD_POWER_OFF, input_dev->keybit);
  input_dev->name = "mode-switch";

  input_register_device(input_dev);

  init_timer (&timer);
  timer.function = timer_func;

  s3c2410_gpio_cfgpin (S3C2410_GPG14, S3C2410_GPG14_EINT22);
  s3c2410_gpio_cfgpin (S3C2410_GPG15, S3C2410_GPG15_EINT23);
  s3c2410_gpio_pullup (S3C2410_GPG14, 0);
  s3c2410_gpio_pullup (S3C2410_GPG15, 0);

  spin_lock_irqsave (init_lock, flags);
  unsigned long x;
  x = __raw_readl (S3C2410_EXTINT2);
  x &= ~(15 << 24);
  x |= S3C2410_EXTINT_BOTHEDGE << 24;
  x |= 1 << 27;
  x &= ~(15 << 28);
  x |= S3C2410_EXTINT_BOTHEDGE << 28;
  x |= 1 << 31;
  __raw_writel (x, S3C2410_EXTINT2);
  spin_unlock_irqrestore (init_lock, flags);

  request_irq(IRQ_EINT22, int_handler, 0, "BAND0", NULL);
  request_irq(IRQ_EINT23, int_handler, 0, "BAND1", NULL);

  /* Register the IOCTL */
  misc_register (&mode_switch_miscdev);

  return 0;
}

/*****************************************************************************
 * Cleanup kernel module
 *****************************************************************************/
static void 
mode_switch_exit(void)
{ 
  del_timer (&timer);

  input_unregister_device(input_dev);
  
  kfree(input_dev);

  s3c2410_gpio_cfgpin (S3C2410_GPG14, S3C2410_GPG14_INP);
  s3c2410_gpio_cfgpin (S3C2410_GPG15, S3C2410_GPG15_INP);

  free_irq (IRQ_EINT22, NULL);
  free_irq (IRQ_EINT23, NULL);

  misc_deregister (&mode_switch_miscdev);
}

MODULE_LICENSE("GPL");

module_init(mode_switch_init);
module_exit(mode_switch_exit);
